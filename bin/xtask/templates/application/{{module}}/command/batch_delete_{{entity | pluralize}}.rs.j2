use anyhow::Result;
use bon::Builder;
use domain::{
    {{module}}::{error::{{module | pascal_case }}Error, event::{{module | pascal_case }}Event, value_object::{{entity}}_id::{{entity | pascal_case}}Id},
    shared::port::domain_repository::DomainRepository,
};
use infrastructure::repository::{{module}}::{{entity}}_repository::{{entity | pascal_case}}RepositoryImpl;
use nject::injectable;
use serde::Deserialize;

use crate::shared::command_handler::{CommandHandler, CommandResult};
use utoipa::ToSchema;

#[derive(Debug, Deserialize, Builder, ToSchema)]
pub struct BatchDelete{{entity | pluralize | pascal_case}}Command {
    ids: Vec<{{entity | pascal_case}}Id>,
}

#[derive(Debug)]
#[injectable]
pub struct BatchDelete{{entity | pluralize | pascal_case}}CommandHandler {
    {{entity}}_repo: {{entity | pascal_case}}RepositoryImpl,
}

impl CommandHandler for BatchDelete{{entity | pluralize | pascal_case}}CommandHandler {
    type Command = BatchDelete{{entity | pluralize | pascal_case}}Command;
    type Output = ();
    type Event = {{module | pascal_case }}Event;
    type Error = {{module | pascal_case }}Error;

    #[tracing::instrument]
    async fn execute(
        &self,
        cmd: Self::Command,
    ) -> Result<CommandResult<Self::Output, Self::Event>, Self::Error> {
        let items = self.{{entity}}_repo.batch_delete(&cmd.ids).await?;
        Ok(CommandResult::with_event(
            (),
            {{module | pascal_case }}Event::{{entity | pluralize | pascal_case}}Deleted { items },
        ))
    }
}
