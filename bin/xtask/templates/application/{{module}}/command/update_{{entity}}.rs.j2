use anyhow::Result;
use bon::Builder;
use domain::{{module}}::{entity::{{entity}}::{{entity | pascal_case}}, value_object::{{entity}}_id::{{entity | pascal_case}}Id};
use domain::shared::domain_repository::DomainRepository;
use infrastructure::repository::{{module}}::{{entity}}_repository::{{entity | pascal_case}}RepositoryImpl;
use serde::Deserialize;
use shared::pool::Pool;

#[derive(Deserialize, Builder)]
pub struct Update{{entity | pascal_case}}Command {
    {%- for field in domain_fields %}
    {{field.name}}: Option<{{field.type}}>,
    {%- endfor %}
}

impl Update{{entity | pascal_case}}Command {
    pub async fn execute(self, id: String, pool: &Pool) -> Result<{{entity | pascal_case}}> {
        let {{entity}}_repo = {{entity | pascal_case}}RepositoryImpl::builder().pool(pool).build();
        let mut {{entity}} = {{entity}}_repo.by_id({{entity | pascal_case}}Id::new_unchecked(id)).await?;
        {%- for field in domain_fields %}
        if let Some({{field.name}}) = self.{{field.name}} {
            {{entity}}.update_{{field.name}}({{field.name}});

        }
        {%- endfor %}
        let {{entity}} = {{entity}}_repo.save({{entity}}).await?;
        Ok({{entity}})
    }
}
