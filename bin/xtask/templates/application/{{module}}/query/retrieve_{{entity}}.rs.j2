use crate::{{module}}::dto::{{entity}}::{{entity | pascal_case}}Dto;
use bon::Builder;
use domain::{{module}}::error::{{module | pascal_case}}Error;
use domain::{{module}}::value_object::{{entity}}_id::{{entity | pascal_case}}Id;
use infrastructure::shared::pg_pool::PgPool;
use nject::injectable;
use serde::Deserialize;
use single_flight::single_flight;
use crate::shared::query_handler::QueryHandler;

#[derive(Debug, Clone, PartialEq, Eq, Hash, Deserialize, Builder)]
pub struct Retrieve{{entity | pascal_case}}Query {
    id: {{entity | pascal_case}}Id,
}

#[derive(Debug)]
#[injectable]
pub struct Retrieve{{entity | pascal_case}}QueryHandler {
    pool: PgPool,
}

impl QueryHandler for Retrieve{{entity | pascal_case}}QueryHandler {
    type Query = Retrieve{{entity | pascal_case}}Query;
    type Output = {{entity | pascal_case}}Dto;
    type Error = {{module | pascal_case}}Error;

    #[single_flight]
    #[tracing::instrument]
    async fn query(&self, query: Retrieve{{entity | pascal_case}}Query) -> Result<{{entity | pascal_case}}Dto, {{module | pascal_case}}Error> {
        let row_opt = sqlx::query_as!(
            {{entity | pascal_case}}Dto,
            r#"
            SELECT {{fields | map(attribute="name") | join(', ')}}
            FROM {{table_name}}
            WHERE id = $1
        "#,
            &query.id,
        )
        .fetch_optional(&self.pool)
        .await?;
        row_opt.ok_or({{module | pascal_case}}Error::{{entity | pascal_case}}NotFound)
    }
}
