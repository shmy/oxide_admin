use anyhow::Result;
use background_job::{GoTo, StepBuilder, StepFn as _, SteppedJob};
use nject::injectable;
use serde::{Deserialize, Serialize};

#[derive(Clone)]
#[injectable]
pub struct {{name | pascal_case}}SteppedJob {}

impl SteppedJob for {{name | pascal_case}}SteppedJob {
    type Begin = {{name | pascal_case}}SteppedJobBegin;

    const NAME: &'static str = "{{name}}_stepped_job";

    const CONCURRENCY: usize = 1;

    fn steps() -> background_job::SteppedJobBuilder<Self> {
        StepBuilder::new()
            .step_fn({{name | pascal_case}}SteppedJobBegin::run)
            .step_fn({{name | pascal_case}}SteppedJobEnd::run)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{name | pascal_case}}SteppedJobBegin {}

impl {{name | pascal_case}}SteppedJobBegin {
    async fn run(_job: Self) -> Result<GoTo<{{name | pascal_case}}SteppedJobEnd>> {
        println!("run {{name | pascal_case}}SteppedJobBegin");
        Ok(GoTo::Next({{name | pascal_case}}SteppedJobEnd {}))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct {{name | pascal_case}}SteppedJobEnd {}

impl {{name | pascal_case}}SteppedJobEnd {
    async fn run(_job: Self) -> Result<GoTo<()>> {
        println!("run {{name | pascal_case}}SteppedJobEnd");
        Ok(GoTo::Done(()))
    }
}
