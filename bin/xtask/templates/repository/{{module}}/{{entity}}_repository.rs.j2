use std::result::Result;

use bon::Builder;
use domain::{{module}}::{
    entity::{{entity}}::{{entity | pascal_case}}, error::{{module | pascal_case}}Error, value_object::{{entity}}_id::{{entity | pascal_case}}Id,
};
use domain::shared::domain_repository::DomainRepository;
use sqlx::{Pool, Sqlite};

#[derive(Builder)]
pub struct {{entity | pascal_case}}RepositoryImpl<'a> {
    pool: &'a Pool<Sqlite>,
}

impl<'a> DomainRepository for {{entity | pascal_case}}RepositoryImpl<'a> {
    type Entity = {{entity | pascal_case}};

    type EntityId = {{entity | pascal_case}}Id;

    type Error = {{module | pascal_case}}Error;

    async fn by_id(&self, id: Self::EntityId) -> Result<Self::Entity, {{module | pascal_case}}Error> {
        let row_opt = sqlx::query!(
            r#"
        SELECT id, {{domain_fields | map(attribute="name") | join(', ')}} FROM {{table_name}} WHERE id = ?
        "#,
            id
        )
        .fetch_optional(self.pool)
        .await
        .map_err({{module | pascal_case}}Error::DatabaseError)?;
        row_opt
            .map(|row| {
                {{entity | pascal_case}}::builder()
                    .id({{entity | pascal_case}}Id::new_unchecked(row.id))
                    {%- for field in domain_fields %}
                    .{{field.name}}(row.{{field.name}})
                    {%- endfor %}
                    .build()
            })
            .ok_or({{module | pascal_case}}Error::{{entity | pascal_case}}NotFound)
    }

    async fn save(&self, entity: Self::Entity) -> Result<Self::Entity, {{module | pascal_case}}Error> {
        let now = chrono::Utc::now().naive_utc();

        sqlx::query!(
            r#"
            INSERT INTO {{table_name}} ({{fields | map(attribute="name") | join(', ')}})
            VALUES (
                    {%- for f in fields -%}
                    {{ "?" }}{{ ", " if not loop.last }}
                    {%- endfor -%}
            )
            ON CONFLICT (id) DO UPDATE SET
                {%- for f in domain_fields %}
                {{f.name}} = EXCLUDED.{{f.name}},
                {%- endfor %}
                updated_at = EXCLUDED.updated_at
            "#,
            entity.id,
            {%- for f in domain_fields %}
            entity.{{f.name}},
            {%- endfor %}
            now,
            now,
        )
        .execute(self.pool)
        .await
        .map_err({{module | pascal_case}}Error::DatabaseError)?;
        Ok(entity)
    }

    async fn batch_delete(&self, ids: Vec<Self::EntityId>) -> Result<(), Self::Error> {
        if ids.is_empty() {
            return Ok(());
        }
        let placeholders = vec!["?"; ids.len()].join(", ");
        let sql = format!("DELETE FROM {{table_name}} WHERE id IN ({})", placeholders);

        let mut query = sqlx::query(&sql);
        for id in ids {
            query = query.bind(id);
        }

        query
            .execute(self.pool)
            .await
            .map_err({{module | pascal_case}}Error::DatabaseError)?;
        Ok(())
    }
}
