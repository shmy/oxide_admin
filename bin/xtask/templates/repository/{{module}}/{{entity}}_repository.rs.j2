use std::result::Result;
use sqlx::FromRow;
use domain::{{module}}::repository::{{entity}}_repository::{{entity | pascal_case}}Repository;
use domain::{{module}}::value_object::{{entity}}_id::{{entity | pascal_case}}Id;
use domain::{{module}}::{entity::{{entity}}::{{entity | pascal_case}}, error::{{module | pascal_case}}Error};
use domain::shared::domain_repository::DomainRepository;
use domain::shared::to_inner_vec::ToInnerVec;
use nject::injectable;

use crate::shared::chrono_tz::ChronoTz;
use crate::shared::pg_pool::PgPool;

#[injectable]
pub struct {{entity | pascal_case}}RepositoryImpl {
    pool: PgPool,
    ct: ChronoTz,
}

impl DomainRepository for {{entity | pascal_case}}RepositoryImpl {
    type Entity = {{entity | pascal_case}};

    type EntityId = {{entity | pascal_case}}Id;

    type Error = {{module | pascal_case}}Error;

    async fn by_id(&self, id: &Self::EntityId) -> Result<Self::Entity, {{module | pascal_case}}Error> {
        let row_opt = sqlx::query_as!(
            {{entity | pascal_case}}Dto,
            r#"
        SELECT id as "id: {{entity | pascal_case}}Id", {{domain_fields | map(attribute="name") | join(', ')}} FROM {{table_name}} WHERE id = $1
        "#,
            id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err({{module | pascal_case}}Error::DatabaseError)?;
        row_opt
            .map(Into::into)
            .ok_or({{module | pascal_case}}Error::{{entity | pascal_case}}NotFound)
    }

    async fn save(&self, entity: Self::Entity) -> Result<Self::Entity, {{module | pascal_case}}Error> {
        let now = self.ct.now();

        sqlx::query!(
            r#"
            INSERT INTO {{table_name}} ({{fields | map(attribute="name") | join(', ')}})
            VALUES (
                    {%- for f in fields -%}
                    {{ "$" ~ loop.index }}{{ ", " if not loop.last }}
                    {%- endfor -%}
            )
            ON CONFLICT (id) DO UPDATE SET
                {%- for f in domain_fields %}
                {{f.name}} = EXCLUDED.{{f.name}},
                {%- endfor %}
                updated_at = EXCLUDED.updated_at
            "#,
            &entity.id,
            {%- for f in domain_fields %}
            &entity.{{f.name}},
            {%- endfor %}
            &now,
            &now,
        )
        .execute(&self.pool)
        .await.map_err({{module | pascal_case}}Error::DatabaseError)?;
        Ok(entity)
    }

    async fn batch_delete(&self, ids: &[Self::EntityId]) -> Result<Vec<Self::Entity>, Self::Error> {
        if ids.is_empty() {
            return Ok(Vec::with_capacity(0));
        }
        let items = sqlx::query_as!(
            {{entity | pascal_case}}Dto,
            r#"
            DELETE FROM {{table_name}} WHERE id = ANY($1) RETURNING id as "id: {{entity | pascal_case}}Id", {{domain_fields | map(attribute="name") | join(', ')}}
            "#,
            &ids.inner_vec()
        )
        .fetch_all(&self.pool)
        .await
        .map_err({{module | pascal_case}}Error::DatabaseError)?;
        let items = items
            .into_iter()
            .map(Into::into)
            .collect();
        Ok(items)
    }
}

impl {{entity | pascal_case}}Repository for {{entity | pascal_case}}RepositoryImpl {}

#[derive(FromRow)]
struct {{entity | pascal_case}}Dto {
    id: {{entity | pascal_case}}Id,
    {%- for field in domain_fields %}
    {{field.name}}: {{field.type}},
    {%- endfor %}
}

impl From<{{entity | pascal_case}}Dto> for {{entity | pascal_case}} {
    fn from(value: {{entity | pascal_case}}Dto) -> Self {
        Self::builder()
            .id(value.id)
            {%- for field in domain_fields %}
            .{{field.name}}(value.{{field.name}})
            {%- endfor %}
            .build()
    }
}
