use application::{
    {{module}}::{
        command::{
            batch_delete_{{entity | pluralize}}::{BatchDelete{{entity | pluralize | pascal_case}}Command, BatchDelete{{entity | pluralize | pascal_case}}CommandHandler},
            create_{{entity}}::{Create{{entity | pascal_case}}Command, Create{{entity | pascal_case}}CommandHandler},
            update_{{entity}}::{Update{{entity | pascal_case}}Command, Update{{entity | pascal_case}}CommandHandler},
        },
        dto::{{entity}}::{{entity | pascal_case}}Dto,
        query::{
            retrieve_{{entity}}::{Retrieve{{entity | pascal_case}}Query, Retrieve{{entity | pascal_case}}QueryHandler},
            search_{{entity}}s::{Search{{entity | pascal_case}}sQuery, Search{{entity | pascal_case}}sQueryHandler},
        },
    },
    shared::{command_handler::CommandHandler, paging_result::PagingResult, query_handler::QueryHandler as _},
};
use axum::{
    Json, Router,
    extract::{Path, Query},
    routing::{get, post, put},
};
use domain::{{module}}::value_object::{{entity}}_id::{{entity | pascal_case}}Id;
use domain::iam::value_object::permission_code::{{(module ~ "_" ~ entity) | uppercase}};

use crate::{
    WebState, perms,
    shared::{
        extractor::inject::Inject,
        middleware::perm_router_ext::PermRouterExt as _,
        response::{JsonResponse, JsonResponsePagingType, JsonResponseType, PagingResponse},
    },
};

#[tracing::instrument]
async fn search(
    Inject(query_handler): Inject<Search{{entity | pascal_case}}sQueryHandler>,
    Query(query): Query<Search{{entity | pascal_case}}sQuery>,
) -> JsonResponsePagingType<{{entity | pascal_case}}Dto> {
    let PagingResult { total, items } = query_handler.query(query).await?;
    JsonResponse::ok(PagingResponse { total, items })
}

#[tracing::instrument]
async fn retrieve(
    Inject(query_handler): Inject<Retrieve{{entity | pascal_case}}QueryHandler>,
    Path(id): Path<{{entity | pascal_case}}Id>,
) -> JsonResponseType<{{entity | pascal_case}}Dto> {
    let {{entity}} = query_handler
        .query(Retrieve{{entity | pascal_case}}Query::builder().id(id).build())
        .await?;
    JsonResponse::ok({{entity}})
}

#[tracing::instrument]
async fn batch_delete(
    Inject(command_handler): Inject<BatchDelete{{entity | pascal_case}}sCommandHandler>,
    Json(command): Json<BatchDelete{{entity | pascal_case}}sCommand>,
) -> JsonResponseType<()> {
    command_handler.handle(command).await?;
    JsonResponse::ok(())
}

#[tracing::instrument]
async fn create(
    Inject(command_handler): Inject<Create{{entity | pascal_case}}CommandHandler>,
    Json(command): Json<Create{{entity | pascal_case}}Command>,
) -> JsonResponseType<()> {
    let _ = command_handler.handle(command).await?;
    JsonResponse::ok(())
}

#[tracing::instrument]
async fn update(
    Inject(command_handler): Inject<Update{{entity | pascal_case}}CommandHandler>,
    Path(_id): Path<{{entity | pascal_case}}Id>,
    Json(command): Json<Update{{entity | pascal_case}}Command>,
) -> JsonResponseType<()> {
    let _ = command_handler.handle(command).await?;
    JsonResponse::ok(())
}

pub fn routing() -> Router<WebState> {
    Router::new()
        .route_with_permission("/", get(search), perms!({{(module ~ "_" ~ entity) | uppercase}}))
        .route_with_permission("/", post(create), perms!({{(module ~ "_" ~ entity) | uppercase}}))
        .route_with_permission("/{id}", get(retrieve), perms!({{(module ~ "_" ~ entity) | uppercase}}))
        .route_with_permission("/{id}", put(update), perms!({{(module ~ "_" ~ entity) | uppercase}}))
        .route_with_permission("/batch/delete", post(batch_delete), perms!({{(module ~ "_" ~ entity) | uppercase}}))
}
