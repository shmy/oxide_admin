use application::{
    {{module}}::{
        command::{
            batch_delete_{{entity | pluralize}}::{BatchDelete{{entity | pluralize | pascal_case}}Command, BatchDelete{{entity | pluralize | pascal_case}}CommandHandler},
            create_{{entity}}::{Create{{entity | pascal_case}}Command, Create{{entity | pascal_case}}CommandHandler},
            update_{{entity}}::{Update{{entity | pascal_case}}Command, Update{{entity | pascal_case}}CommandHandler},
        },
        dto::{{entity}}::{{entity | pascal_case}}Dto,
        query::{
            retrieve_{{entity}}::{Retrieve{{entity | pascal_case}}Query, Retrieve{{entity | pascal_case}}QueryHandler},
            search_{{entity | pluralize}}::{Search{{entity | pluralize| pascal_case}}Query, Search{{entity | pluralize| pascal_case}}QueryHandler},
        },
    },
    shared::{command_handler::CommandHandler, paging_result::PagingResult, query_handler::QueryHandler as _},
};
use axum::{Json, extract::{Path, Query}};
use domain::{{module}}::value_object::{{entity}}_id::{{entity | pascal_case}}Id;
use domain::iam::value_object::permission::{
    {{(module ~ "_" ~ entity) | uppercase}}_READ,
    {{(module ~ "_" ~ entity) | uppercase}}_CREATE,
    {{(module ~ "_" ~ entity) | uppercase}}_UPDATE,
    {{(module ~ "_" ~ entity) | uppercase}}_DELETE,
};
use utoipa_axum::{router::OpenApiRouter, routes};

use crate::{
    WebState, perms,
    shared::{
        extractor::inject::Inject,
        middleware::perm_router_ext::PermissonRouteExt as _,
        response::{JsonResponse, JsonResponseEmpty, JsonResponsePagingType, JsonResponseType, PagingResponse},
    },
};

#[utoipa::path(
    get,
    params(Search{{entity | pluralize| pascal_case}}Query),
    path = "/",
    summary = "Search {{entity | pluralize}}",
    tag = "{{module | pascal_case}}",
    responses(
        (status = 200, body = inline(JsonResponse<PagingResponse<{{entity | pascal_case}}Dto>>))
    )
)]
#[tracing::instrument]
async fn search(
    Inject(query_handler): Inject<Search{{entity | pluralize| pascal_case}}QueryHandler>,
    Query(query): Query<Search{{entity | pluralize| pascal_case}}Query>,
) -> JsonResponsePagingType<{{entity | pascal_case}}Dto> {
    let PagingResult { total, items } = query_handler.query(query).await?;
    JsonResponse::ok(PagingResponse { total, items })
}

#[utoipa::path(
    get,
    path = "/{id}",
    summary = "Retrieve {{entity}}",
    tag = "{{module | pascal_case}}",
    responses(
        (status = 200, body = inline(JsonResponse<{{entity | pascal_case}}Dto>))
    )
)]
#[tracing::instrument]
async fn retrieve(
    Inject(query_handler): Inject<Retrieve{{entity | pascal_case}}QueryHandler>,
    Path(id): Path<{{entity | pascal_case}}Id>,
) -> JsonResponseType<{{entity | pascal_case}}Dto> {
    let {{entity}} = query_handler
        .query(Retrieve{{entity | pascal_case}}Query::builder().id(id).build())
        .await?;
    JsonResponse::ok({{entity}})
}

#[utoipa::path(
    post,
    path = "/batch/delete",
    summary = "Batch delete {{entity | pluralize}}",
    tag = "{{module | pascal_case}}",
    responses(
        (status = 200, body = inline(JsonResponseEmpty))
    )
)]
#[tracing::instrument]
async fn batch_delete(
    Inject(command_handler): Inject<BatchDelete{{entity | pluralize | pascal_case}}CommandHandler>,
    Json(command): Json<BatchDelete{{entity | pluralize | pascal_case}}Command>,
) -> JsonResponseType<()> {
    command_handler.handle(command).await?;
    JsonResponse::ok(())
}

#[utoipa::path(
    post,
    path = "/",
    summary = "Create {{entity}}",
    tag = "{{module | pascal_case}}",
    responses(
        (status = 200, body = inline(JsonResponseEmpty))
    )
)]
#[tracing::instrument]
async fn create(
    Inject(command_handler): Inject<Create{{entity | pascal_case}}CommandHandler>,
    Json(command): Json<Create{{entity | pascal_case}}Command>,
) -> JsonResponseType<()> {
    let _ = command_handler.handle(command).await?;
    JsonResponse::ok(())
}

#[utoipa::path(
    put,
    path = "/{id}",
    summary = "Update {{entity}}",
    tag = "{{module | pascal_case}}",
    responses(
        (status = 200, body = inline(JsonResponseEmpty))
    )
)]
#[tracing::instrument]
async fn update(
    Inject(command_handler): Inject<Update{{entity | pascal_case}}CommandHandler>,
    Path(_id): Path<{{entity | pascal_case}}Id>,
    Json(command): Json<Update{{entity | pascal_case}}Command>,
) -> JsonResponseType<()> {
    let _ = command_handler.handle(command).await?;
    JsonResponse::ok(())
}

pub fn routing() -> OpenApiRouter<WebState> {
    OpenApiRouter::new()
        .routes(routes!(search).permit_all(perms!({{(module ~ "_" ~ entity) | uppercase}}_READ)))
        .routes(routes!(retrieve).permit_all(perms!({{(module ~ "_" ~ entity) | uppercase}}_READ)))
        .routes(routes!(create).permit_all(perms!({{(module ~ "_" ~ entity) | uppercase}}_CREATE)))
        .routes(routes!(update).permit_all(perms!({{(module ~ "_" ~ entity) | uppercase}}_UPDATE)))
        .routes(routes!(batch_delete).permit_all(perms!({{(module ~ "_" ~ entity) | uppercase}}_DELETE)))
}
